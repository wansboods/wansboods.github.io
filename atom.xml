<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>甲子· 映像</title>
  <subtitle>生活點滴積累</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://127.0.0.1:4000/"/>
  <updated>2016-09-25T08:25:28.816Z</updated>
  <id>http://127.0.0.1:4000/</id>
  
  <author>
    <name>sean.Wan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux IO多路复用之epoll网络编程</title>
    <link href="http://127.0.0.1:4000/2016/09/25/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://127.0.0.1:4000/2016/09/25/IO多路复用之epoll网络编程/</id>
    <published>2016-09-24T16:00:00.000Z</published>
    <updated>2016-09-25T08:25:28.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a><strong>服务端代码</strong></h2><blockquote>
<p>epoll_server.c</p>
</blockquote>
<p>```</p>
<p>#include  <unistd.h></unistd.h></p>
<p>#include  <sys types.h="">       /<em> basic system data types </em>/</sys></p>
<p>#include  <sys socket.h="">      /<em> basic socket definitions </em>/</sys></p>
<p>#include  <netinet in.h="">      /<em> sockaddr_in{} and other Internet defns </em>/</netinet></p>
<p>#include  <arpa inet.h="">       /<em> inet(3) functions </em>/</arpa></p>
<p>#include <sys epoll.h=""> /<em> epoll function </em>/</sys></p>
<p>#include <fcntl.h>     /<em> nonblocking </em>/</fcntl.h></p>
<p>#include <sys resource.h=""> /<em>setrlimit </em>/</sys></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>#include <errno.h></errno.h></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <string.h></string.h></p>
<p>#define MAXEPOLLSIZE 10000</p>
<p>#define MAXLINE 10240<br>int handle(int connfd);<br>int setnonblocking(int sockfd)<br>{<br>    if (fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFD, 0)|O_NONBLOCK) == -1) {<br>        return -1;<br>    }<br>    return 0;<br>}</p>
<p>int main(int argc, char **argv)<br>{<br>    int  servPort = 6888;<br>    int listenq = 1024;</p>
<pre><code>int listenfd, connfd, kdpfd, nfds, n, nread, curfds,acceptCount = 0;
struct sockaddr_in servaddr, cliaddr;
socklen_t socklen = sizeof(struct sockaddr_in);
struct epoll_event ev;
struct epoll_event events[MAXEPOLLSIZE];
struct rlimit rt;
char buf[MAXLINE];

/* 设置每个进程允许打开的最大文件数 */
rt.rlim_max = rt.rlim_cur = MAXEPOLLSIZE;
if (setrlimit(RLIMIT_NOFILE, &amp;rt) == -1) 
{
    perror(&quot;setrlimit error&quot;);
    return -1;
}


bzero(&amp;servaddr, sizeof(servaddr));
servaddr.sin_family = AF_INET; 
servaddr.sin_addr.s_addr = htonl (INADDR_ANY);
servaddr.sin_port = htons (servPort);

listenfd = socket(AF_INET, SOCK_STREAM, 0); 
if (listenfd == -1) {
    perror(&quot;can&apos;t create socket file&quot;);
    return -1;
}

int opt = 1;
setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));

if (setnonblocking(listenfd) &lt; 0) {
    perror(&quot;setnonblock error&quot;);
}

if (bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(struct sockaddr)) == -1) 
{
    perror(&quot;bind error&quot;);
    return -1;
} 
if (listen(listenfd, listenq) == -1) 
{
    perror(&quot;listen error&quot;);
    return -1;
}
/* 创建 epoll 句柄，把监听 socket 加入到 epoll 集合里 */
kdpfd = epoll_create(MAXEPOLLSIZE);
ev.events = EPOLLIN | EPOLLET;
ev.data.fd = listenfd;
if (epoll_ctl(kdpfd, EPOLL_CTL_ADD, listenfd, &amp;ev) &lt; 0) 
{
    fprintf(stderr, &quot;epoll set insertion error: fd=%d\n&quot;, listenfd);
    return -1;
}
curfds = 1;

printf(&quot;epollserver startup,port %d, max connection is %d, backlog is %d\n&quot;, servPort, MAXEPOLLSIZE, listenq);

for (;;) {
    /* 等待有事件发生 */
    nfds = epoll_wait(kdpfd, events, curfds, -1);
    if (nfds == -1)
    {
        perror(&quot;epoll_wait&quot;);
        continue;
    }
    /* 处理所有事件 */
    for (n = 0; n &lt; nfds; ++n)
    {
        if (events[n].data.fd == listenfd) 
        {
            connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr,&amp;socklen);
            if (connfd &lt; 0) 
            {
                perror(&quot;accept error&quot;);
                continue;
            }

            sprintf(buf, &quot;accept form %s:%d\n&quot;, inet_ntoa(cliaddr.sin_addr), cliaddr.sin_port);
            printf(&quot;%d:%s&quot;, ++acceptCount, buf);

            if (curfds &gt;= MAXEPOLLSIZE) {
                fprintf(stderr, &quot;too many connection, more than %d\n&quot;, MAXEPOLLSIZE);
                close(connfd);
                continue;
            } 
            if (setnonblocking(connfd) &lt; 0) {
                perror(
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务端代码&quot;&gt;&lt;a href=&quot;#服务端代码&quot; class=&quot;headerlink&quot; title=&quot;服务端代码&quot;&gt;&lt;/a&gt;&lt;strong&gt;服务端代码&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;epoll_server.c&lt;/p&gt;
&lt;/blockqu
    
    </summary>
    
      <category term="Linux" scheme="http://127.0.0.1:4000/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://127.0.0.1:4000/tags/Linux/"/>
    
      <category term="编程" scheme="http://127.0.0.1:4000/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>硬盘SMART检测参数详解</title>
    <link href="http://127.0.0.1:4000/2016/01/02/%E7%A1%AC%E7%9B%98SMART%E6%A3%80%E6%B5%8B%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://127.0.0.1:4000/2016/01/02/硬盘SMART检测参数详解/</id>
    <published>2016-01-01T16:00:00.000Z</published>
    <updated>2016-09-25T03:40:07.896Z</updated>
    
    <content type="html"><![CDATA[<p>现代硬件驱动器一般支持SMART（自我监测分析和报告技术），它能够监视整个硬盘驱动器的健康状况，并且当硬盘驱动器即将故障的时候会发出警告。</p>
<p>一般硬件厂商提供的磁盘工具，是在系统重启后检查磁盘驱动的健康状况，而SMART可以不用重启系统就可以检查硬盘驱动器的健康程度。</p>
<p>在linux中，工具包的名字为 <strong>smartmontools</strong></p>
<p>在CentOS中可以使用 yum install smartmontools来安装工具<br>首先通过smartctl -i /dev/sda 来检查一下硬盘是否具有 SMART 特性</p>
<p>下面是smart工具的说明文档，里面有<a href="https://www.smartmontools.org/" target="_blank" rel="external">详细的说明</a></p>
<p>这个是我在虚拟机中测试的不支持<br><img src="http://www.linuxidc.com/upload/2014_07/140725095423431.png" alt=""><br>这个是我在真服务器中测试的，支持<br>SMART support 是 Disabled 状态的话，需要开启 SMART 的支持：<br>然后使用smartctl -H /dev/sda来检测磁盘的健康状况<br>查看/dev/sda当前整体监控状态。PASSED表示健康，否则意味着磁盘已经故障，或很快就会发生故障。</p>
<p><img src="http://www.linuxidc.com/upload/2014_07/140725095423432.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">smartctl -s on /dev/sda</div><div class="line">smartctl -H /dev/sda&lt;/code&gt;</div></pre></td></tr></table></figure>
<p>使用</p>
<p>smartctl -t short /dev/sda</p>
<p>做一个快速自检</p>
<p>smartctl -l selftest /dev/sda</p>
<p>查看自检的进度和结果</p>
<p>使用smartctl -t long /dev/sda 做长时间自检，这个很耗时，一般放在凌晨</p>
<p>使用smartctl -l error /dev/sda查看出错日志</p>
<p>在这里，我的读、写都没有发生错误，在Non-medium error count 中出现错误6。</p>
<p>我一直没有搞懂（非媒介错误计数）这个是什么意思，在官方文档查了一下，出现如下：</p>
<p>non-medium error counter (only a single number displayed). This represents the number of recoverable events other than write, read or verify errors.</p>
<p>我大致理解了一下，是除了read,write,verify errors的错误，可恢复事件的数量</p>
<p>查看所有信息<br>打印/dev/sda所有的SMART信息。<br>smartctl -a /dev/sda<br>相当于依次执行：<br>smartctl –i /dev/sda<br>smartctl -c /dev/sda<br>smartctl -A /dev/sda<br>smartctl -l error /dev/sda<br>smartctl -l selftest /dev/sda<br>smartctl -l selective /dev/sda<br>开/关SMART功能<br>打开或关闭/dev/sda 的SMART功能。<br>smartctl -s on/off /dev/sda<br>查看当前SMART功能是否开启，可以使用 –i 参数。<br>smartctl -i /dev/sda<br>离线测试<br>对/dev/sda进行离线测试，它的结果主要用来更新SMART 属性。<br>smartctl -t offline /dev/sda<br>观察测试进度<br>通过-c 参数，可以观察到测试的进度：<br>smartctl -c /dev/sda</p>
<p>smartctl参数帮助</p>
<p>-h 帮助信息<br>-V 版本信息<br>-i 打印基本信息（磁盘设备号、序列号、固件版本…）<br>-a 打印磁盘所有的SMART信息<br>运行时行为 参数：<br>-q TYPE 指定输出的安静模式。<br>TYPE可以有3种选择：<br>eorsonly 只打印错误日志。<br>slent 有任何打印。<br>nserial 不打印序列号<br>-d TYPE 指定磁盘的类型。如果没有指定，smartctl会根据磁盘的名字来<br>猜测磁盘类型。<br>-T TYPE 指定当发生错误时，smartctl的容忍程度，是否继续运行。<br>TYPE可以有4种选择：<br>conservative 一有错就会退出<br>normal 如果必须支持的SMART命令失败，则退出<br>permissive 忽略一次必须支持的SMART命令失败<br>verypermissive 忽略所有必须支持的SMART命令失败<br>-b TYPE 指定当发生校验错误时，smartctl的动作。<br>TYPE有3种选择：<br>warn 发出警告，继续执行<br>exit 退出smartctl<br>ignore 不发出告警，继续执行<br>-r TYPE smartmontools开发人员相关。<br>-n POWERMODE 指定当磁盘处于节能模式时，smartctl是否继续检查，<br>默认是不检查。<br>POWERMODE有4种选择：<br>never 检查<br>sleep 除了sleep模式，检查。<br>standby 除了sleep或standby模式，检查。<br>idle 除了sleep或standby或idle模式，见车。<br>SMART功能开关 参数：<br>-s on/off 打开或关闭磁盘的SMART功能<br>-o on/off 打开或关闭SMART自动离线检测，该功能每4小时就会自动扫描磁盘是<br>否有缺陷。<br>-S on/off 打开或关闭“自动保存厂商指定属性”功能。<br>SMART 读和显示数据 参数<br>-H 报告磁盘的是否健康。如果报告不健康，则说明磁盘已经损坏或会在24小时<br>内损坏。<br>-c 显示磁盘支持的普通SMART功能，以及这些功能当前的状态。<br>-A 显示磁盘支持的厂商指定SMART特性。这些特性的编号从1-253，并且有指<br>定的名字。<br>-l TYPE 指定显示的log类型。<br>TYPE有4种选择：<br>error 只显示error log。<br>selftest 只显示selftest log<br>selective 只显示selective self-test log<br>directory 只显示Log Directory<br>-v N,OPTION 显示厂商指定SMART特性N时，使用厂商相关的显示方式。<br>-F TYPE 设置smartctl的行为，当出现一些已知但还没有解决的硬件或软件bug时，<br>smartctl应该怎么做。<br>-P TYPE 设置smartctl是否对磁盘使用数据库中已有的参数。<br>SMART 离线测试、自测试 参数<br>-t TEST 立刻执行测试，可以和-C参数一起使用。<br>TEST可以有以下几个选择：<br>offline 离线测试。可以在挂载文件系统的磁盘上使用<br>short 短时间测试。可以在挂载文件系统的磁盘上使用。<br>long 长时间测试。可以在挂载文件系统的磁盘上使用。<br>conveyance [ATA only]传输zi测试。可以在挂载文件系统的磁盘上使用。<br>select, N-M<br>select, N+SIZE [ATA only]有选择性测试，测试磁盘的部分LBA。N表示<br>LBA编号，M表示结束LBA编号，SIZE表示测试的LBA<br>范围。<br>-C 在captive模式下运行测试。<br>注意：（1）-C必须配合-t一起使用，但如果是-t offline，则-C不生效。<br>（2）-C会使得磁盘很忙，所以最好是在没有挂载文件系统的磁盘上使用。<br>-X 中断no-captive模式下运行的测试</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代硬件驱动器一般支持SMART（自我监测分析和报告技术），它能够监视整个硬盘驱动器的健康状况，并且当硬盘驱动器即将故障的时候会发出警告。&lt;/p&gt;
&lt;p&gt;一般硬件厂商提供的磁盘工具，是在系统重启后检查磁盘驱动的健康状况，而SMART可以不用重启系统就可以检查硬盘驱动器的健康
    
    </summary>
    
      <category term="Linux" scheme="http://127.0.0.1:4000/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://127.0.0.1:4000/tags/Linux/"/>
    
      <category term="硬盘操作" scheme="http://127.0.0.1:4000/tags/%E7%A1%AC%E7%9B%98%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
</feed>
